{"ast":null,"code":"const EventEmitter = require('events').EventEmitter;\n\nconst inherits = require('util').inherits;\n\nconst Stoplight = require('./util/stoplight.js');\n\nconst cacheUtils = require('./util/rpc-cache-utils.js');\n\nconst createPayload = require('./util/create-payload.js');\n\nconst ethUtil = require('ethereumjs-util');\n\nconst async = require('async');\n\nmodule.exports = Web3ProviderEngine;\ninherits(Web3ProviderEngine, EventEmitter);\n\nfunction Web3ProviderEngine(opts) {\n  const self = this;\n  EventEmitter.call(self);\n  self.setMaxListeners(30); // set initialization blocker\n\n  self._ready = new Stoplight(); // unblock initialization after first block\n\n  self.once('block', function () {\n    self._ready.go();\n  }); // parse options\n\n  opts = opts || {};\n  self._pollingShouldUnref = opts.pollingShouldUnref !== false;\n  self._pollingInterval = opts.pollingInterval || 4000; // local state\n\n  self.currentBlock = null;\n  self._providers = [];\n} // public\n\n\nWeb3ProviderEngine.prototype.start = function () {\n  const self = this; // start block polling\n\n  self._startPolling();\n};\n\nWeb3ProviderEngine.prototype.stop = function () {\n  const self = this; // stop block polling\n\n  self._stopPolling();\n};\n\nWeb3ProviderEngine.prototype.addProvider = function (source) {\n  const self = this;\n\n  self._providers.push(source);\n\n  source.setEngine(this);\n};\n\nWeb3ProviderEngine.prototype.send = function (payload) {\n  throw new Error('Web3ProviderEngine does not support synchronous requests.');\n};\n\nWeb3ProviderEngine.prototype.sendAsync = function (payload, cb) {\n  const self = this;\n\n  self._ready.await(function () {\n    if (Array.isArray(payload)) {\n      // handle batch\n      async.map(payload, self._handleAsync.bind(self), cb);\n    } else {\n      // handle single\n      self._handleAsync(payload, cb);\n    }\n  });\n}; // private\n\n\nWeb3ProviderEngine.prototype._handleAsync = function (payload, finished) {\n  var self = this;\n  var currentProvider = -1;\n  var result = null;\n  var error = null;\n  var stack = [];\n  next();\n\n  function next(after) {\n    currentProvider += 1;\n    stack.unshift(after); // Bubbled down as far as we could go, and the request wasn't\n    // handled. Return an error.\n\n    if (currentProvider >= self._providers.length) {\n      end(new Error('Request for method \"' + payload.method + '\" not handled by any subprovider. Please check your subprovider configuration to ensure this method is handled.'));\n    } else {\n      try {\n        var provider = self._providers[currentProvider];\n        provider.handleRequest(payload, next, end);\n      } catch (e) {\n        end(e);\n      }\n    }\n  }\n\n  function end(_error, _result) {\n    error = _error;\n    result = _result;\n    async.eachSeries(stack, function (fn, callback) {\n      if (fn) {\n        fn(error, result, callback);\n      } else {\n        callback();\n      }\n    }, function () {\n      // console.log('COMPLETED:', payload)\n      // console.log('RESULT: ', result)\n      var resultObj = {\n        id: payload.id,\n        jsonrpc: payload.jsonrpc,\n        result: result\n      };\n\n      if (error != null) {\n        resultObj.error = {\n          message: error.stack || error.message || error,\n          code: -32000\n        }; // respond with both error formats\n\n        finished(error, resultObj);\n      } else {\n        self._inspectResponseForNewBlock(payload, resultObj, finished);\n      }\n    });\n  }\n}; //\n// from remote-data\n//\n\n\nWeb3ProviderEngine.prototype._startPolling = function () {\n  const self = this;\n\n  self._fetchLatestBlock();\n\n  self._pollIntervalId = setInterval(function () {\n    self._fetchLatestBlock();\n  }, self._pollingInterval); // Tell node that block polling shouldn't keep the process open.\n  // https://nodejs.org/api/timers.html#timers_timeout_unref\n\n  if (self._pollIntervalId.unref && self._pollingShouldUnref) {\n    self._pollIntervalId.unref();\n  }\n};\n\nWeb3ProviderEngine.prototype._stopPolling = function () {\n  const self = this;\n  clearInterval(self._pollIntervalId);\n};\n\nWeb3ProviderEngine.prototype._fetchLatestBlock = function (cb) {\n  if (!cb) cb = function (err) {\n    if (err) return console.error(err);\n  };\n  const self = this;\n\n  self._fetchBlock('latest', function (err, block) {\n    if (err) {\n      self.emit('error', err);\n      return cb(err);\n    }\n\n    if (!self.currentBlock || 0 !== self.currentBlock.hash.compare(block.hash)) {\n      self._setCurrentBlock(block);\n    }\n\n    cb(null, block);\n  });\n};\n\nWeb3ProviderEngine.prototype._setCurrentBlock = function (block) {\n  const self = this;\n  self.currentBlock = block;\n  self.emit('block', block);\n};\n\nWeb3ProviderEngine.prototype._fetchBlock = function (number, cb) {\n  const self = this; // skip: cache, readiness, block number rewrite\n\n  self._handleAsync(createPayload({\n    method: 'eth_getBlockByNumber',\n    params: [number, false]\n  }), function (err, resultObj) {\n    if (err) return cb(err);\n    if (resultObj.error) return cb(resultObj.error);\n    var data = resultObj.result; // json -> buffers\n\n    var block = {\n      number: ethUtil.toBuffer(data.number),\n      hash: ethUtil.toBuffer(data.hash),\n      parentHash: ethUtil.toBuffer(data.parentHash),\n      nonce: ethUtil.toBuffer(data.nonce),\n      sha3Uncles: ethUtil.toBuffer(data.sha3Uncles),\n      logsBloom: ethUtil.toBuffer(data.logsBloom),\n      transactionsRoot: ethUtil.toBuffer(data.transactionsRoot),\n      stateRoot: ethUtil.toBuffer(data.stateRoot),\n      receiptsRoot: ethUtil.toBuffer(data.receiptRoot || data.receiptsRoot),\n      miner: ethUtil.toBuffer(data.miner),\n      difficulty: ethUtil.toBuffer(data.difficulty),\n      totalDifficulty: ethUtil.toBuffer(data.totalDifficulty),\n      size: ethUtil.toBuffer(data.size),\n      extraData: ethUtil.toBuffer(data.extraData),\n      gasLimit: ethUtil.toBuffer(data.gasLimit),\n      gasUsed: ethUtil.toBuffer(data.gasUsed),\n      timestamp: ethUtil.toBuffer(data.timestamp),\n      transactions: data.transactions\n    };\n    cb(null, block);\n  });\n};\n\nWeb3ProviderEngine.prototype._inspectResponseForNewBlock = function (payload, resultObj, cb) {\n  // these methods return responses with a block reference\n  if (payload.method != 'eth_getTransactionByHash' && payload.method != 'eth_getTransactionReceipt') {\n    return cb(null, resultObj);\n  }\n\n  if (resultObj.result == null || resultObj.result.blockNumber == null) {\n    return cb(null, resultObj);\n  }\n\n  var blockNumber = ethUtil.toBuffer(resultObj.result.blockNumber); // If we found a new block number on the result,\n  // fetch the block details before returning the original response.\n  // We do this b/c a user might be polling for a tx by hash,\n  // and when getting a response may assume that we are on the new block and\n  // try to query data from that block but would otherwise get old data due to\n  // our blockTag-rewriting mechanism\n\n  if (0 !== this.currentBlock.number.compare(blockNumber)) {\n    this._fetchLatestBlock(function (err, block) {\n      cb(null, resultObj);\n    });\n  } else {\n    cb(null, resultObj);\n  }\n}; // util\n\n\nfunction SourceNotFoundError(payload) {\n  return new Error('Source for RPC method \"' + payload.method + '\" not found.');\n}","map":{"version":3,"sources":["/home/fitsh/Code/practice/blockchain/ethStudy/lotteryProject/node_modules/_web3-provider-engine@8.6.1@web3-provider-engine/index.js"],"names":["EventEmitter","require","inherits","Stoplight","cacheUtils","createPayload","ethUtil","async","module","exports","Web3ProviderEngine","opts","self","call","setMaxListeners","_ready","once","go","_pollingShouldUnref","pollingShouldUnref","_pollingInterval","pollingInterval","currentBlock","_providers","prototype","start","_startPolling","stop","_stopPolling","addProvider","source","push","setEngine","send","payload","Error","sendAsync","cb","await","Array","isArray","map","_handleAsync","bind","finished","currentProvider","result","error","stack","next","after","unshift","length","end","method","provider","handleRequest","e","_error","_result","eachSeries","fn","callback","resultObj","id","jsonrpc","message","code","_inspectResponseForNewBlock","_fetchLatestBlock","_pollIntervalId","setInterval","unref","clearInterval","err","console","_fetchBlock","block","emit","hash","compare","_setCurrentBlock","number","params","data","toBuffer","parentHash","nonce","sha3Uncles","logsBloom","transactionsRoot","stateRoot","receiptsRoot","receiptRoot","miner","difficulty","totalDifficulty","size","extraData","gasLimit","gasUsed","timestamp","transactions","blockNumber","SourceNotFoundError"],"mappings":"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","sourcesContent":["const EventEmitter = require('events').EventEmitter\nconst inherits = require('util').inherits\nconst Stoplight = require('./util/stoplight.js')\nconst cacheUtils = require('./util/rpc-cache-utils.js')\nconst createPayload = require('./util/create-payload.js')\nconst ethUtil = require('ethereumjs-util')\nconst async = require('async')\n\nmodule.exports = Web3ProviderEngine\n\n\ninherits(Web3ProviderEngine, EventEmitter)\n\nfunction Web3ProviderEngine(opts) {\n  const self = this\n  EventEmitter.call(self)\n  self.setMaxListeners(30)\n  // set initialization blocker\n  self._ready = new Stoplight()\n  // unblock initialization after first block\n  self.once('block', function(){\n    self._ready.go()\n  })\n  // parse options\n  opts = opts || {}\n  self._pollingShouldUnref = opts.pollingShouldUnref !== false\n  self._pollingInterval = opts.pollingInterval || 4000\n  // local state\n  self.currentBlock = null\n  self._providers = []\n}\n\n// public\n\nWeb3ProviderEngine.prototype.start = function(){\n  const self = this\n  // start block polling\n  self._startPolling()\n}\n\nWeb3ProviderEngine.prototype.stop = function(){\n  const self = this\n  // stop block polling\n  self._stopPolling()\n}\n\nWeb3ProviderEngine.prototype.addProvider = function(source){\n  const self = this\n  self._providers.push(source)\n  source.setEngine(this)\n}\n\nWeb3ProviderEngine.prototype.send = function(payload){\n  throw new Error('Web3ProviderEngine does not support synchronous requests.')\n}\n\nWeb3ProviderEngine.prototype.sendAsync = function(payload, cb){\n  const self = this\n  self._ready.await(function(){\n\n    if (Array.isArray(payload)) {\n      // handle batch\n      async.map(payload, self._handleAsync.bind(self), cb)\n    } else {\n      // handle single\n      self._handleAsync(payload, cb)\n    }\n\n  })\n}\n\n// private\n\nWeb3ProviderEngine.prototype._handleAsync = function(payload, finished) {\n  var self = this\n  var currentProvider = -1\n  var result = null\n  var error = null\n\n  var stack = []\n\n  next()\n\n  function next(after) {\n    currentProvider += 1\n    stack.unshift(after)\n\n    // Bubbled down as far as we could go, and the request wasn't\n    // handled. Return an error.\n    if (currentProvider >= self._providers.length) {\n      end(new Error('Request for method \"' + payload.method + '\" not handled by any subprovider. Please check your subprovider configuration to ensure this method is handled.'))\n    } else {\n      try {\n        var provider = self._providers[currentProvider]\n        provider.handleRequest(payload, next, end)\n      } catch (e) {\n        end(e)\n      }\n    }\n  }\n\n  function end(_error, _result) {\n    error = _error\n    result = _result\n\n    async.eachSeries(stack, function(fn, callback) {\n\n      if (fn) {\n        fn(error, result, callback)\n      } else {\n        callback()\n      }\n    }, function() {\n      // console.log('COMPLETED:', payload)\n      // console.log('RESULT: ', result)\n\n      var resultObj = {\n        id: payload.id,\n        jsonrpc: payload.jsonrpc,\n        result: result\n      }\n\n      if (error != null) {\n        resultObj.error = {\n          message: error.stack || error.message || error,\n          code: -32000\n        }\n        // respond with both error formats\n        finished(error, resultObj)\n      } else {\n        self._inspectResponseForNewBlock(payload, resultObj, finished)\n      }\n    })\n  }\n}\n\n//\n// from remote-data\n//\n\nWeb3ProviderEngine.prototype._startPolling = function(){\n  const self = this\n\n  self._fetchLatestBlock()\n\n  self._pollIntervalId = setInterval(function() {\n    self._fetchLatestBlock()\n  }, self._pollingInterval)\n\n  // Tell node that block polling shouldn't keep the process open.\n  // https://nodejs.org/api/timers.html#timers_timeout_unref\n  if (self._pollIntervalId.unref && self._pollingShouldUnref) {\n    self._pollIntervalId.unref()\n  }\n}\n\nWeb3ProviderEngine.prototype._stopPolling = function(){\n  const self = this\n  clearInterval(self._pollIntervalId)\n}\n\nWeb3ProviderEngine.prototype._fetchLatestBlock = function(cb) {\n  if (!cb) cb = function(err) { if (err) return console.error(err) }\n\n  const self = this\n\n  self._fetchBlock('latest', function(err, block) {\n    if (err) {\n      self.emit('error', err)\n      return cb(err)\n    }\n\n    if (!self.currentBlock || 0 !== self.currentBlock.hash.compare(block.hash)) {\n      self._setCurrentBlock(block)\n    }\n\n    cb(null, block)\n  })\n}\n\nWeb3ProviderEngine.prototype._setCurrentBlock = function(block){\n  const self = this\n  self.currentBlock = block\n  self.emit('block', block)\n}\n\nWeb3ProviderEngine.prototype._fetchBlock = function(number, cb){\n  const self = this\n\n  // skip: cache, readiness, block number rewrite\n  self._handleAsync(createPayload({\n    method: 'eth_getBlockByNumber',\n    params: [number, false],\n  }), function(err, resultObj){\n    if (err) return cb(err)\n    if (resultObj.error) return cb(resultObj.error)\n    var data = resultObj.result;\n\n\n    // json -> buffers\n    var block = {\n      number:           ethUtil.toBuffer(data.number),\n      hash:             ethUtil.toBuffer(data.hash),\n      parentHash:       ethUtil.toBuffer(data.parentHash),\n      nonce:            ethUtil.toBuffer(data.nonce),\n      sha3Uncles:       ethUtil.toBuffer(data.sha3Uncles),\n      logsBloom:        ethUtil.toBuffer(data.logsBloom),\n      transactionsRoot: ethUtil.toBuffer(data.transactionsRoot),\n      stateRoot:        ethUtil.toBuffer(data.stateRoot),\n      receiptsRoot:     ethUtil.toBuffer(data.receiptRoot || data.receiptsRoot),\n      miner:            ethUtil.toBuffer(data.miner),\n      difficulty:       ethUtil.toBuffer(data.difficulty),\n      totalDifficulty:  ethUtil.toBuffer(data.totalDifficulty),\n      size:             ethUtil.toBuffer(data.size),\n      extraData:        ethUtil.toBuffer(data.extraData),\n      gasLimit:         ethUtil.toBuffer(data.gasLimit),\n      gasUsed:          ethUtil.toBuffer(data.gasUsed),\n      timestamp:        ethUtil.toBuffer(data.timestamp),\n      transactions:     data.transactions,\n    }\n\n    cb(null, block)\n  })\n}\n\nWeb3ProviderEngine.prototype._inspectResponseForNewBlock = function(payload, resultObj, cb) {\n\n  // these methods return responses with a block reference\n  if (payload.method != 'eth_getTransactionByHash'\n   && payload.method != 'eth_getTransactionReceipt') {\n    return cb(null, resultObj)\n  }\n\n  if (resultObj.result == null || resultObj.result.blockNumber == null) {\n    return cb(null, resultObj)\n  }\n\n  var blockNumber = ethUtil.toBuffer(resultObj.result.blockNumber)\n\n  // If we found a new block number on the result,\n  // fetch the block details before returning the original response.\n  // We do this b/c a user might be polling for a tx by hash,\n  // and when getting a response may assume that we are on the new block and\n  // try to query data from that block but would otherwise get old data due to\n  // our blockTag-rewriting mechanism\n  if (0 !== this.currentBlock.number.compare(blockNumber)) {\n    this._fetchLatestBlock(function(err, block) {\n      cb(null, resultObj)\n    })\n  } else {\n    cb(null, resultObj)\n  }\n\n}\n\n// util\n\nfunction SourceNotFoundError(payload){\n  return new Error('Source for RPC method \"'+payload.method+'\" not found.')\n}\n\n"]},"metadata":{},"sourceType":"script"}